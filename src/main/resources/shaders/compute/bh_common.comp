// =============================================================
// Common definitions, structs, buffers, and helpers
// =============================================================
layout(local_size_x = 256u) in;
const uint WG_SIZE = 256u; // Must match local_size_x above and WORK_GROUP_SIZE in Java

//Uniforms
//Update uniforms:
uniform uint firstPass;
//Force uniforms:
uniform float softening;
uniform float theta;
uniform float dt;
uniform float elasticity;
uniform float density;
uniform float restitution;
uniform bool collision;
uniform bool mergeToggle;
uniform bool wrapAround;
//Radix sort uniforms:
uniform uint passShift;
//Common uniforms:
uniform uint numWorkGroups;

//To change these, you need to also change them in BoundedBarnesHut.java
//Radix sort constants:
const uint RADIX_BITS = 4u;
const uint NUM_BUCKETS = 1u << RADIX_BITS;


//Common structs:
//Representation of a celestial body
struct Body { 
    //position (x,y,z) and mass (w)
    vec4 posMass; 
    //velocity (x,y,z) and density (w)
    vec4 velDensity;};

//Representation of an axis aligned bounding box
struct AABB {
    //minimum corner of the bounding box
    vec3 minCorner;
    //maximum corner of the bounding box
    vec3 maxCorner;
};

//Representation of a node in the radix tree
struct Node {
    //center of mass (x,y,z) and mass (w)
    vec4 comMass;
    //stored as a uint[6] to avoid padding
    float[6] aabb;
    //children of the node
    uint childA;
    uint childB;
    //depth of the node
    uint nodeDepth;
    //number of bodies contained in the node
    uint bodiesContained;
    //number of ready children of the node (used in updating the tree)
    uint readyChildren;
    //parent of the node
    uint parentId;
};

//SSBO bindings:
//Leaf nodes of the radix tree (node representation of a body).
//  -Initialized with numBodies nodes (In Java: numBodies * Node.STRUCT_SIZE * Integer.BYTES)
layout(std430, binding = 0)  buffer LeafNodes          { Node leafNodes[]; };
//Internal nodes of the radix tree.
//  -Initialized with numBodies - 1 nodes (In Java: (numBodies - 1) * Node.STRUCT_SIZE * Integer.BYTES)
layout(std430, binding = 1)  buffer InternalNodes      { Node internalNodes[]; };
//Simulation values
//  -Initialized to exactly fit the values. (In Java: 8*Integer.BYTES+8*Float.BYTES+100*Integer.BYTES+100*Float.BYTES)
layout(std430, binding = 2)  buffer SimulationValues   { uint numBodies; uint initialNumBodies; uint justDied; uint merged; 
                                                        uint outOfBounds; uint pad0; uint pad1; uint pad2; 
                                                        AABB bounds; uint uintDebug[100]; float floatDebug[100]; } sim;
//Bodies of the simulation from the previous step
//  -Initialized with numBodies bodies (In Java: numBodies * Body.STRUCT_SIZE * Float.BYTES)
layout(std430, binding = 3)  buffer BodiesIn           { Body bodies[]; } srcB;
//Bodies of the simulation to be used in the next step
//  -Initialized with numBodies bodies (In Java: numBodies * Body.STRUCT_SIZE * Float.BYTES)
layout(std430, binding = 4)  buffer BodiesOut          { Body bodies[]; } dstB;
//Morton codes of the bodies of the simulation double buffered for dead partitioning and radix sort
//  -Initialized with numBodies morton codes (In Java: numBodies * Long.BYTES)
layout(std430, binding = 5)  buffer MortonIn           { uint64_t mortonIn[]; };
layout(std430, binding = 6)  buffer MortonOut          { uint64_t mortonOut[]; };
//Sorted index of the bodies of the simulation double buffered for dead partitioning and radix sort
//  -Initialized with numBodies indices (In Java: numBodies * Integer.BYTES)
layout(std430, binding = 7)  buffer IndexIn            { uint indexIn[]; };
layout(std430, binding = 8)  buffer IndexOut           { uint indexOut[]; };
//Work queue for propagating node data up the tree from the leaves. Double buffered for performance.
//  -Initialized with numBodies indices (In Java: (4 + numBodies) * Integer.BYTES)
layout(std430, binding = 9)  buffer WorkQueueIn        { uint headIn; uint tailIn; uint itemsIn[]; };
layout(std430, binding = 10)  buffer WorkQueueOut       { uint headOut; uint tailOut; uint itemsOut[]; };
//Per work group histogram of the radix sort buckets Reused for dead counting 
//  -Initialized with numWorkGroups * NUM_BUCKETS histogram bars (uints) (In Java: numWorkGroups * NUM_BUCKETS * Integer.BYTES)
layout(std430, binding = 11) buffer RadixWGHist        { uint wgHist[];      };
//Per work group inclusive sum of the radix sort buckets across all work groups Reused for dead counting
//  -Initialized with numWorkGroups * NUM_BUCKETS inclusive sums (uints) (In Java: numWorkGroups * NUM_BUCKETS * Integer.BYTES)
layout(std430, binding = 12) buffer RadixWGScanned     { uint wgScanned[];   };
//Radix bucket totals and global base for radix sort scatter
//  -Initialized with numBodies buckets (uints) and numBodies global bases (uints) (In Java: NUM_BUCKETS * Integer.BYTES + NUM_BUCKETS * Integer.BYTES)
layout(std430, binding = 13) buffer RadixBucketTotals  { uint bucketTotals[NUM_BUCKETS]; uint globalBase[NUM_BUCKETS];};
//Merge queue for merging bodies
//  -Initialized with numBodies bodies (In Java: numBodies * Integer.BYTES)
layout(std430, binding = 14) buffer MergeQueue         { uint mergeQueueHead; uint mergeQueueTail; uvec2 mergeQueue[];};
//Merge body locks to avoid races when merging bodies
//  -Initialized with numBodies bodies (In Java: numBodies * Integer.BYTES)
layout(std430, binding = 15) buffer MergeBodyLocks     { uint bodyLocks[]; };


const Body EMPTY_BODY = Body(vec4(0.0), vec4(0.0));

bool isEmpty(Body b) {
    return b.posMass.w == 0.0;
}

bool outOfBounds(Body b) {
    return b.posMass.x < sim.bounds.minCorner.x || b.posMass.x > sim.bounds.maxCorner.x ||
           b.posMass.y < sim.bounds.minCorner.y || b.posMass.y > sim.bounds.maxCorner.y ||
           b.posMass.z < sim.bounds.minCorner.z || b.posMass.z > sim.bounds.maxCorner.z;
}

float radius(Body b) {
    return pow(b.posMass.w, 1.0/3.0)/b.velDensity.w;
}

AABB updateAABB(AABB a, AABB b) {
    AABB result;
    result.minCorner = min(a.minCorner, b.minCorner);
    result.maxCorner = max(a.maxCorner, b.maxCorner);
    return result;
}

// Helper function to convert float[6] to AABB
AABB getAABB(float[6] aabb) {
    return AABB(vec3(aabb[0], aabb[1], aabb[2]), vec3(aabb[3], aabb[4], aabb[5]));
}

// Helper function to convert AABB to uint[6]
float[6] packAABB(AABB aabb) {
    return float[6](aabb.minCorner.x, aabb.minCorner.y, aabb.minCorner.z, aabb.maxCorner.x, aabb.maxCorner.y, aabb.maxCorner.z);
}