// =============================================================
//      Common definitions, structs, buffers, and helpers
// =============================================================
layout(local_size_x = 256u) in;
const uint WG_SIZE = 256u; // Must match local_size_x above and WORK_GROUP_SIZE in Java

//To change these, you need to also change them in BoundedBarnesHut.java
//Radix sort constants:
const uint RADIX_BITS = 4u;
const uint NUM_BUCKETS = 1u << RADIX_BITS;


//Common structs:
//Representation of a celestial body
struct Body { 
    //position (x,y,z) and mass (w)
    vec4 posMass; 
    //velocity (x,y,z) and density (w)
    vec4 velDensity;};

//Representation of an axis aligned bounding box
struct AABB {
    //minimum corner of the bounding box
    vec3 minCorner;
    //maximum corner of the bounding box
    vec3 maxCorner;
};

//Representation of a node in the radix tree
struct Node {
    //center of mass (x,y,z) and mass (w)
    vec4 comMass;
    //stored as a float[6] to avoid padding
    float[6] aabb;
    //children of the node
    uint childA;
    uint childB;
    //depth of the node
    uint nodeDepth;
    //number of bodies contained in the node
    uint bodiesContained;
    //number of ready children of the node (used in updating the tree)
    uint readyChildren;
    //parent of the node
    uint parentId;
};

//SSBO bindings:
//Leaf nodes of the radix tree (node representation of a body).
//  -Initialized with numBodies nodes (In Java: numBodies * Node.STRUCT_SIZE * Integer.BYTES)
layout(std430, binding = 0)  buffer LeafNodes          { Node leafNodes[]; };
//Internal nodes of the radix tree.
//  -Initialized with numBodies - 1 nodes (In Java: (numBodies - 1) * Node.STRUCT_SIZE * Integer.BYTES)
layout(std430, binding = 1)  buffer InternalNodes      { Node internalNodes[]; };
//Simulation values
//  -Initialized to exactly fit the values. (In Java: 8*Integer.BYTES+8*Float.BYTES+100*Integer.BYTES+100*Float.BYTES)
layout(std430, binding = 2)  buffer SimulationValues   { uint numBodies; uint initialNumBodies; uint justDied; uint merged; 
                                                        uint outOfBounds; uint pad0; uint pad1; uint pad2; 
                                                        AABB bounds; uint uintDebug[100]; float floatDebug[100]; } sim;
//Bodies of the simulation from the previous step
//  -Initialized with numBodies bodies (In Java: numBodies * Body.STRUCT_SIZE * Float.BYTES)
layout(std430, binding = 3)  buffer BodiesIn           { Body bodies[]; } srcB;
//Bodies of the simulation to be used in the next step
//  -Initialized with numBodies bodies (In Java: numBodies * Body.STRUCT_SIZE * Float.BYTES)
layout(std430, binding = 4)  buffer BodiesOut          { Body bodies[]; } dstB;
//Morton codes of the bodies of the simulation double buffered for dead partitioning and radix sort
//  -Initialized with numBodies morton codes (uint64_t's) (In Java: numBodies * Long.BYTES)
layout(std430, binding = 5)  buffer MortonIn           { uint64_t mortonIn[]; };
layout(std430, binding = 6)  buffer MortonOut          { uint64_t mortonOut[]; };
//Sorted index of the bodies of the simulation double buffered for dead partitioning and radix sort
//  -Initialized with numBodies indices (uints) (In Java: numBodies * Integer.BYTES)
layout(std430, binding = 7)  buffer IndexIn            { uint indexIn[]; };
layout(std430, binding = 8)  buffer IndexOut           { uint indexOut[]; };
//Work queue for propagating node data up the tree from the leaves. Double buffered for performance.
//  -Initialized with numBodies indices (uints) (In Java: (4 + numBodies) * Integer.BYTES)
layout(std430, binding = 9)  buffer WorkQueueIn        { uint headIn; uint tailIn; uint itemsIn[]; };
layout(std430, binding = 10)  buffer WorkQueueOut       { uint headOut; uint tailOut; uint itemsOut[]; };
//Per work group histogram of the radix sort buckets. Reused for dead sorting 
//  -Initialized with numWorkGroups * NUM_BUCKETS histogram bars (uints) (In Java: numWorkGroups * NUM_BUCKETS * Integer.BYTES)
layout(std430, binding = 11) buffer RadixWGHist        { uint wgHist[];      };
//Per work group inclusive sum of the radix sort buckets across all work groups. Reused for dead sorting
//  -Initialized with numWorkGroups * NUM_BUCKETS inclusive sums (uints) (In Java: numWorkGroups * NUM_BUCKETS * Integer.BYTES)
layout(std430, binding = 12) buffer RadixWGScanned     { uint wgScanned[];   };
//  -Initialized with numBodies buckets (uints) and numBodies global bases (uints) (In Java: NUM_BUCKETS * Integer.BYTES + NUM_BUCKETS * Integer.BYTES)
layout(std430, binding = 13) buffer RadixBucketTotalsAndAABB  { uint bucketTotals[NUM_BUCKETS]; uint globalBase[NUM_BUCKETS]; };
//Merge queue for merging bodies identified in the force kernel
//  -Initialized with numBodies pairs of indices (uint[2]'s) (In Java: numBodies * Integer.BYTES)
layout(std430, binding = 14) buffer MergeQueue         { uint mergeQueueHead; uint mergeQueueTail; uvec2 mergeQueue[];};
//Merge body locks to avoid races when merging bodies
//  -Initialized with numBodies locks (uints) (In Java: numBodies * Integer.BYTES)
layout(std430, binding = 15) buffer MergeBodyLocks     { uint bodyLocks[]; };


//Uniforms
//Update uniforms:
uniform uint resetValuesOrDecrementDeadBodies; //Used to determine if the update kernel is resetting values or decrementing dead bodies
//Force uniforms: 
uniform float softening; //Used to soften the force calculation (F ∝ (r+softening)^-2)
uniform float theta; //Used to determine acceptance criterion for force calculation in node traversal
uniform float dt; // Time step used to update the position and velocity of bodies
uniform uint collisionMergingOrNeither; // Selects collision, merging, or neither. 0 = neither, 1 = collision, 2 = merging, 3 = both
uniform float elasticity; //Elasticity of collisions
uniform float restitution; //Restitution of overlapping bodies in collisions 
uniform float bothCriterion; //Used to determine if the body is colliding or merging
uniform bool wrapAround; //If the simulation wraps around or kills OOB bodies 
uniform uint staticOrDynamic; //If the simulation is static or dynamic
//Radix sort uniforms:
uniform uint passShift; //Pass shift for radix sort passes.
//Common uniforms:
uniform uint numWorkGroups; //Used to determine the number of work groups during the radix sort

//Constants for the collisionMergingOrNeither uniform
const uint NEITHER = 0u;
const uint COLLISION = 1u;
const uint MERGING = 2u;
const uint BOTH = 3u;
//Constants for the dynamic uniform
const uint STATIC = 0u;
const uint DYNAMIC = 1u;
//Empty body constant for merged bodies or OOB bodies
const Body EMPTY_BODY = Body(vec4(0.0), vec4(0.0));

//Numerical Constants
const float PI = 3.14159265358979323846;
const float THREE_OVER_FOUR_PI_TO_THE_THIRD = 0.6203504909; 
const float GRAVITATIONAL_CONSTANT = 6.67430e-11; //m^3 kg^-1 s^-2
const float STELLAR_DENSITY = 1.408e3; //kg/m^3
const float SOLAR_MASS = 1.989e30; //kg


//Checks if a body is empty
bool isEmpty(Body b) {
    return b.posMass.w == 0.0;
}

//Checks if a body is out of bounds
bool outOfBounds(Body b) {
    return b.posMass.x < sim.bounds.minCorner.x || b.posMass.x > sim.bounds.maxCorner.x ||
           b.posMass.y < sim.bounds.minCorner.y || b.posMass.y > sim.bounds.maxCorner.y ||
           b.posMass.z < sim.bounds.minCorner.z || b.posMass.z > sim.bounds.maxCorner.z;
}

float density(Body b) {
    return b.velDensity.w*STELLAR_DENSITY;
}

float mass(Body b) {
    return b.posMass.w*SOLAR_MASS;
}

float mass(Node node) {
    return node.comMass.w*SOLAR_MASS;
}

//Calculates the radius of a body
float radius(Body b) {

    return THREE_OVER_FOUR_PI_TO_THE_THIRD * pow((mass(b)/density(b)), 1.0/3.0);
}

//Creates an AABB that is the union of two AABBs
AABB updateAABB(AABB a, AABB b) {
    AABB result;
    result.minCorner = min(a.minCorner, b.minCorner);
    result.maxCorner = max(a.maxCorner, b.maxCorner);
    return result;
}

// Converts a float[6] to an AABB
AABB unpackAABB(float[6] aabb) {
    return AABB(vec3(aabb[0], aabb[1], aabb[2]), vec3(aabb[3], aabb[4], aabb[5]));
}

// Converts an AABB to a float[6]
float[6] packAABB(AABB aabb) {
    return float[6](aabb.minCorner.x, aabb.minCorner.y, aabb.minCorner.z, aabb.maxCorner.x, aabb.maxCorner.y, aabb.maxCorner.z);
}
// Gets a node from the leaf or internal nodes buffer depending on the index
Node getNode(uint nodeIdx) {
    return nodeIdx < sim.initialNumBodies ? leafNodes[nodeIdx] : internalNodes[nodeIdx-sim.initialNumBodies];
}
// Checks if a node is an internal node
bool isInternalNode(Node node) {
    return node.childA != 0xFFFFFFFFu;
}