// =============================================================
//                      Morton encoding
// =============================================================

// Take the 21-bit integer and expands it 
uint64_t expandBits21(uint v) {

    uint64_t x = uint64_t(v) & 0x1FFFFFul;      //0b0000000000000000000000000000000000000000000111111111111111111111ul
    x = (x | (x << 32)) & 0x1F00000000FFFFul;   //0b0000000111110000000000000000000000000000000011111111111111111111ul
    x = (x | (x << 16)) & 0x1F0000FF0000FFul;   //0b0000000000011111000000000000000011111111000000000000000011111111ul
    x = (x | (x << 8))  & 0x100F00F00F00F00Ful; //0b0000010000000011110000000011110000000011110000000011110000000011ul
    x = (x | (x << 4))  & 0x10C30C30C30C30C3ul; //0b0001000011000011000011000011000011000011000011000011000011000011ul
    x = (x | (x << 2))  & 0x1249249249249249ul; //0b0001001001001001001001001001001001001001001001001001001001001001ul
    return x;
}

// Encodes a 3D position into a 64-bit Morton code
uint64_t morton3D64(uint x, uint y, uint z)
{   //This shifts the bits to the left by 2, 1, and 0 and then expands them to interleave them over all 63 bits used
    return (expandBits21(x) << 2) | (expandBits21(y) << 1) | expandBits21(z);
}

// Encodes a 3D position into a 64-bit Morton code
uint64_t mortonEncode3D(vec3 pNorm)
{
    const float MAX_VALUE = 2097151.0; //0b0000000000000000000000000000000000000000000111111111111111111111ul;
    float fx = clamp(floor(pNorm.x * MAX_VALUE), 0.0, MAX_VALUE);
    float fy = clamp(floor(pNorm.y * MAX_VALUE), 0.0, MAX_VALUE);
    float fz = clamp(floor(pNorm.z * MAX_VALUE), 0.0, MAX_VALUE);
    uint xi = uint(floor(fx));
    uint yi = uint(floor(fy));
    uint zi = uint(floor(fz));
    return morton3D64(xi, yi, zi);
}


// Encodes a 3D position into a 64-bit Morton code
// Dispached with (numGroups,0,0) with workgroup size * numGroups = numBodies
// Uniforms: None
// SSBOs: BodiesIn, BodiesOut, IndexIn, IndexOut
void mortonEncodeKernel()
{
    uint gid = gl_GlobalInvocationID.x;
    if (gid >= sim.numBodies) return;


    //get the index of the body
    uint bodyIdx = indexIn[gid];

    Body body = srcB.bodies[bodyIdx];

    AABB scene = sim.bounds;
    vec3 pos = srcB.bodies[bodyIdx].posMass.xyz;
    vec3 extent = max(scene.maxCorner - scene.minCorner, vec3(1e-9));
    vec3 pNorm = (pos - scene.minCorner) / extent; //normalize the position to the range [0,1]^3

    mortonIn[gid] = mortonEncode3D(pNorm); //encode the normalized position into a 64-bit Morton code
}


