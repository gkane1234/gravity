// =============================================================
//                         Merge bodies
// =============================================================
// Merges two bodies into one
Body mergeBodies(Body body1, Body body2) {
    Body mergedBody;    
    float newMass = body1.posMass.w + body2.posMass.w;
    if (newMass == 0.0) {
        return EMPTY_BODY;
    }
    if (body1.posMass.w == 0.0) {
        return body2;
    }
    if (body2.posMass.w == 0.0) {
        return body1;
    }
    vec3 newPos = (body1.posMass.xyz * body1.posMass.w + body2.posMass.xyz * body2.posMass.w) / newMass;
    mergedBody.posMass.xyz = newPos;
    mergedBody.posMass.w = newMass;
    mergedBody.velDensity.xyz = (body1.velDensity.xyz * body1.posMass.w + body2.velDensity.xyz * body2.posMass.w) / newMass;
    mergedBody.velDensity.w = (body1.posMass.w+body2.posMass.w)/(body1.posMass.w/body1.velDensity.w+body2.posMass.w/body2.velDensity.w);
    return mergedBody;
}
// Traverses the merge queue and merges the bodies.
//Note this takes from and reads to the output buffer since we are using modified data from the force kernel.
// This is not a deterministic kernel, and will simply skip over pairs if there is a race condition.
// Dispached with (numGroups,0,0) with workgroup size * numGroups = numBodies
// Uniforms: None
// SSBOs: BodiesIn, BodiesOut, MergeQueue, MergeBodyLocks
void mergeBodiesKernel() {
    for (;;) {
        // Atomically claim a queue slot
        uint workIdx = atomicAdd(mergeQueueHead, 1u);
        if (workIdx >= mergeQueueTail) break;

        uvec2 pair = mergeQueue[workIdx];
        uint iA = pair.x;
        uint iB = pair.y;

        if (iA == iB) continue; // skip invalid pairs

        // Lock both bodies (order by index to avoid deadlock)
        uint first  = min(iA, iB);
        uint second = max(iA, iB);

        if (atomicCompSwap(bodyLocks[first], 0u, 1u) != 0u) {
            // could not lock first, already locked
            continue; // Skip this pair
        }
        if (atomicCompSwap(bodyLocks[second], 0u, 1u) != 0u) {
            // could not lock second, already locked
            // release first, then skip
            bodyLocks[first] = 0u;
            continue; // Skip this pair
        }

        // Both locked
        Body body1 = dstB.bodies[iA]; //Takes from the output buffer
        Body body2 = dstB.bodies[iB]; //Takes from the output buffer

        if (!isEmpty(body1) && !isEmpty(body2)) {   
            Body merged = mergeBodies(body1, body2);
            dstB.bodies[iA] = merged; //Writes to the output buffer
            dstB.bodies[iB] = EMPTY_BODY; //Writes to the output buffer

            atomicAdd(sim.merged, 1u); //Increment the number of merged bodies for simulation tracking
        }

        // Unlock both
        bodyLocks[first] = 0u;
        bodyLocks[second] = 0u;
    }
}