// =============================================================
//                      Morton encoding
// =============================================================

// Take the 21-bit integer and expands it 
uint64_t expandBits21(uint v) {

    uint64_t x = uint64_t(v) & 0x1FFFFFul;      //0b0000000000000000000000000000000000000000000111111111111111111111ul
    x = (x | (x << 32)) & 0x1F00000000FFFFul;   //0b0000000111110000000000000000000000000000000011111111111111111111ul
    x = (x | (x << 16)) & 0x1F0000FF0000FFul;   //0b0000000000011111000000000000000011111111000000000000000011111111ul
    x = (x | (x << 8))  & 0x100F00F00F00F00Ful; //0b0000010000000011110000000011110000000011110000000011110000000011ul
    x = (x | (x << 4))  & 0x10C30C30C30C30C3ul; //0b0001000011000011000011000011000011000011000011000011000011000011ul
    x = (x | (x << 2))  & 0x1249249249249249ul; //0b0001001001001001001001001001001001001001001001001001001001001001ul
    return x;
}

// Encodes a 3D position into a 64-bit Morton code
uint64_t morton3D64(uint x, uint y, uint z)
{   //This shifts the bits to the left by 2, 1, and 0 and then expands them to interleave them over all 63 bits used
    return (expandBits21(x) << 2) | (expandBits21(y) << 1) | expandBits21(z);
}

// Encodes a 3D position into a 64-bit Morton code
uint64_t mortonEncode3D(vec3 pNorm)
{
    const float MAX_VALUE = 2097151.0; //0b0000000000000000000000000000000000000000000111111111111111111111ul;
    float fx = clamp(floor(pNorm.x * MAX_VALUE), 0.0, MAX_VALUE);
    float fy = clamp(floor(pNorm.y * MAX_VALUE), 0.0, MAX_VALUE);
    float fz = clamp(floor(pNorm.z * MAX_VALUE), 0.0, MAX_VALUE);
    uint xi = uint(floor(fx));
    uint yi = uint(floor(fy));
    uint zi = uint(floor(fz));
    return morton3D64(xi, yi, zi);
}
shared AABB sharedAABB[WG_SIZE];
//Collapses the AABB's from shared memory into one AABB at sharedAABB[0]
//Done in parallel for each workgroup
void collapseSharedAABB() {
    uint lid = gl_LocalInvocationID.x;
    uint activePairs = WG_SIZE;
    while (activePairs > 1u) {
        uint stride = activePairs / 2u;
        if (lid < stride) {
            uint other = lid + stride;
            sharedAABB[lid] = updateAABB(sharedAABB[lid], sharedAABB[other]);
        }
        barrier();
        activePairs = stride;
    }
}


//Updates the AABB of the alive bodies in the simulation
//Dispached with (numGroups,0,0) with workgroup size * numGroups = numBodies
// Uniforms: None
// SSBOs: BodiesIn, BodiesOut, IndexIn, IndexOut, InternalNodes
void mortonAABBRepopulateKernel() {
    uint gid = gl_GlobalInvocationID.x;
    uint lid = gl_LocalInvocationID.x;

    uint leftBodyIdx = 0u;
    uint rightBodyIdx = 0u;
    bool laneHasBodies = 2*gid < sim.numBodies;

    if (!laneHasBodies) {
        sharedAABB[lid] = AABB(vec3(1e9), vec3(-1e9));
    }
    else {

        //Load AABB's into the shared memory
        //We combine two bodies into each AABB to save time

        leftBodyIdx = indexIn[2*gid];

        if (2*gid+1 >= sim.numBodies) {
            // Only one body left
            if (isEmpty(srcB.bodies[leftBodyIdx])) {
                sharedAABB[lid] = AABB(vec3(1e9), vec3(-1e9));
            } else {
                vec3 pos = srcB.bodies[leftBodyIdx].posMass.xyz;
                sharedAABB[lid] = AABB(pos, pos);
            }
        } else {
            rightBodyIdx = indexIn[2*gid+1];
            bool leftEmpty  = isEmpty(srcB.bodies[leftBodyIdx]);
            bool rightEmpty = isEmpty(srcB.bodies[rightBodyIdx]);

            if (leftEmpty && rightEmpty) {
                sharedAABB[lid] = AABB(vec3(1e9), vec3(-1e9));
            } else if (rightEmpty) {
                vec3 pos = srcB.bodies[leftBodyIdx].posMass.xyz;
                sharedAABB[lid] = AABB(pos, pos);
            } else if (leftEmpty) {
                vec3 pos = srcB.bodies[rightBodyIdx].posMass.xyz;
                sharedAABB[lid] = AABB(pos, pos);
            } else {
                vec3 pos0 = srcB.bodies[leftBodyIdx].posMass.xyz;
                vec3 pos1 = srcB.bodies[rightBodyIdx].posMass.xyz;
                sharedAABB[lid] = AABB(min(pos0, pos1), max(pos0, pos1));
            }
        }
    }
    barrier();

    collapseSharedAABB();

    if (lid == 0u) {
        sim.uintDebug[5]=sim.numBodies;
        sim.uintDebug[6]=laneHasBodies ? (isEmpty(srcB.bodies[leftBodyIdx])?1u:0u) : 0xFFFFFFFFu;
        sim.floatDebug[7]=sharedAABB[0].minCorner.x;
        sim.floatDebug[8]=sharedAABB[0].minCorner.y;
        sim.floatDebug[9]=sharedAABB[0].minCorner.z;
        sim.floatDebug[10]=sharedAABB[0].maxCorner.x;
        sim.floatDebug[11]=sharedAABB[0].maxCorner.y;
        sim.floatDebug[12]=sharedAABB[0].maxCorner.z;

        if (laneHasBodies) {
            sim.floatDebug[1]=srcB.bodies[leftBodyIdx].posMass.x;
            sim.floatDebug[2]=srcB.bodies[leftBodyIdx].posMass.y;
            sim.floatDebug[3]=srcB.bodies[leftBodyIdx].posMass.z;
        } else {
            sim.floatDebug[1]=0.0;
            sim.floatDebug[2]=0.0;
            sim.floatDebug[3]=0.0;
        }
        uint wgId = gl_WorkGroupID.x;
        if (laneHasBodies) {
            uint totalWorkGroups = gl_NumWorkGroups.x;
            if (wgId < totalWorkGroups)
                internalNodes[wgId].aabb = packAABB(sharedAABB[0]);
        }

            sim.floatDebug[13+wgId]=internalNodes[wgId].aabb[0];
        
    }
}


//Collapses the AABB's from shared memory into the AABB of the simulation
void mortonAABBCollapseKernel() {

    uint lid = gl_LocalInvocationID.x;
    uint wgId = gl_WorkGroupID.x;
    uint regionSize = (numWorkGroups + WG_SIZE -1 ) / WG_SIZE; //ceil(numWorkGroups/WG_SIZE)
    
    uint regionStart = lid*regionSize;


    bool laneActive = regionStart < numWorkGroups;
    AABB laneAABB;
    if (laneActive) {
        laneAABB = unpackAABB(internalNodes[regionStart].aabb);
        for (uint i = regionStart+1; i < min(regionStart + regionSize, numWorkGroups); ++i) {
            laneAABB = updateAABB(laneAABB, unpackAABB(internalNodes[i].aabb));
        }
    } else {
        laneAABB = AABB(vec3(1e9), vec3(-1e9));
    }
    sharedAABB[lid] = laneAABB;

    barrier();

    collapseSharedAABB();

    if (lid == 0u) {
        sim.bounds = sharedAABB[0];
    }
}


// Encodes a 3D position into a 64-bit Morton code
// Dispached with (numGroups,0,0) with workgroup size * numGroups = numBodies
// Uniforms: None
// SSBOs: BodiesIn, BodiesOut, IndexIn, IndexOut
void mortonEncodeKernel()
{
    uint gid = gl_GlobalInvocationID.x;
    if (gid >= sim.numBodies) return;


    //get the index of the body
    uint bodyIdx = indexIn[gid];

    Body body = srcB.bodies[bodyIdx];

    AABB scene = sim.bounds;
    vec3 pos = srcB.bodies[bodyIdx].posMass.xyz;
    vec3 extent = max(scene.maxCorner - scene.minCorner, vec3(1e-9));
    vec3 pNorm = (pos - scene.minCorner) / extent; //normalize the position to the range [0,1]^3

    mortonIn[gid] = mortonEncode3D(pNorm); //encode the normalized position into a 64-bit Morton code
}


